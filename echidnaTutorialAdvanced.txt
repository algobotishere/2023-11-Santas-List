Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

advanced/
â”œâ”€â”€ README.md
â”œâ”€â”€ collecting-a-corpus.md
â”œâ”€â”€ end-to-end-testing.md
â”œâ”€â”€ finding-transactions-with-high-gas-consumption.md
â”œâ”€â”€ hevm-cheats-to-test-permit.md
â”œâ”€â”€ interacting-with-offchain-data-via-ffi.md
â”œâ”€â”€ on-using-cheat-codes.md
â”œâ”€â”€ optimization_mode.md
â”œâ”€â”€ smart-contract-fuzzing-at-scale.md
â”œâ”€â”€ state-network-forking.md
â”œâ”€â”€ testing-bytecode.md
â”œâ”€â”€ using-all-contracts.md
â””â”€â”€ working-with-libraries.md

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] README.md
# Advanced

- [How to Collect a Corpus](./collecting-a-corpus.md): Learn how to use Echidna to gather a corpus of transactions.
- [How to Use Optimization Mode](./optimization_mode.md): Discover how to optimize a function using Echidna.
- [How to Detect High Gas Consumption](./finding-transactions-with-high-gas-consumption.md): Find out how to identify functions with high gas consumption.
- [How to Perform Large-scale Smart Contract Fuzzing](./smart-contract-fuzzing-at-scale.md): Explore how to use Echidna for long fuzzing campaigns on complex smart contracts.
- [How to Test a Library](https://blog.trailofbits.com/2020/08/17/using-echidna-to-test-a-smart-contract-library/): Learn about using Echidna to test the Set Protocol library (blog post).
- [How to Test Bytecode-only Contracts](./testing-bytecode.md): Learn how to fuzz contracts without source code or perform differential fuzzing between Solidity and Vyper.
- [How and when to use cheat codes](./on-using-cheat-codes.md): How to use hevm cheat codes in general
- [How to Use Hevm Cheats to Test Permit](./hevm-cheats-to-test-permit.md): Find out how to test code that relies on ecrecover signatures by using hevm cheat codes.
- [How to Seed Echidna with Unit Tests](./end-to-end-testing.md): Discover how to use existing unit tests to seed Echidna.
- [Understanding and Using `allContracts`](./using-all-contracts.md): Learn what `allContracts` testing is and how to utilize it effectively.
- [How to do on-chain fuzzing with state forking](./state-network-forking.md): How Echidna can use the state of blockchain during a fuzzing campaign
- [Interacting with off-chain data via FFI cheatcode](./interacting-with-offchain-data-via-ffi.md): Using the `ffi` cheatcode as a way of communicating with the operating system

[File Ends] README.md

[File Begins] collecting-a-corpus.md
# Collecting, Visualizing, and Modifying an Echidna Corpus

**Table of contents:**

- [Introduction](#introduction)
- [Collecting a corpus](#collecting-a-corpus)
- [Seeding a corpus](#seeding-a-corpus)

## Introduction

In this guide, we will explore how to collect and use a corpus of transactions with Echidna. Our target is the following smart contract, [magic.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/magic.sol):

```solidity
contract C {
    bool value_found = false;

    function magic(uint256 magic_1, uint256 magic_2, uint256 magic_3, uint256 magic_4) public {
        require(magic_1 == 42);
        require(magic_2 == 129);
        require(magic_3 == magic_4 + 333);
        value_found = true;
        return;
    }

    function echidna_magic_values() public view returns (bool) {
        return !value_found;
    }
}
```

This small example requires Echidna to find specific values to change a state variable. While this is challenging for a fuzzer (it is advised to use a symbolic execution tool like [Manticore](https://github.com/trailofbits/manticore)), we can still employ Echidna to collect corpus during this fuzzing campaign.

## Collecting a corpus

To enable corpus collection, first, create a corpus directory:

```
mkdir corpus-magic
```

Next, create an [Echidna configuration file](https://github.com/crytic/echidna/wiki/Config) called `config.yaml`:

```yaml
corpusDir: "corpus-magic"
```

Now, run the tool and inspect the collected corpus:

```
echidna magic.sol --config config.yaml
```

Echidna is still unable to find the correct magic value. To understand where it gets stuck, review the `corpus-magic/covered.*.txt` file:

```
  1 | *   | contract C {
  2 |     |     bool value_found = false;
  3 |     |
  4 | *   |     function magic(uint256 magic_1, uint256 magic_2, uint256 magic_3, uint256 magic_4) public {
  5 | *r  |         require(magic_1 == 42);
  6 | *r  |         require(magic_2 == 129);
  7 | *r  |         require(magic_3 == magic_4 + 333);
  8 |     |         value_found = true;
  9 |     |         return;
 10 |     |     }
 11 |     |
 12 |     |     function echidna_magic_values() public returns (bool) {
 13 |     |         return !value_found;
 14 |     |     }
 15 |     | }
```

The label `r` on the left of each line indicates that Echidna can reach these lines, but they result in a revert. As you can see, the fuzzer gets stuck at the last `require`.

To find a workaround, let's examine the collected corpus. For instance, one of these files contains:

```json
[
    {
        "_gas'": "0xffffffff",
        "_delay": ["0x13647", "0xccf6"],
        "_src": "00a329c0648769a73afac7f9381e08fb43dbea70",
        "_dst": "00a329c0648769a73afac7f9381e08fb43dbea72",
        "_value": "0x0",
        "_call": {
            "tag": "SolCall",
            "contents": [
                "magic",
                [
                    {
                        "contents": [
                            256,
                            "93723985220345906694500679277863898678726808528711107336895287282192244575836"
                        ],
                        "tag": "AbiUInt"
                    },
                    {
                        "contents": [256, "334"],
                        "tag": "AbiUInt"
                    },
                    {
                        "contents": [
                            256,
                            "68093943901352437066264791224433559271778087297543421781073458233697135179558"
                        ],
                        "tag": "AbiUInt"
                    },
                    {
                        "tag": "AbiUInt",
                        "contents": [256, "332"]
                    }
                ]
            ]
        },
        "_gasprice'": "0xa904461f1"
    }
]
```

This input will not trigger the failure in our property. In the next step, we will show how to modify it for that purpose.

## Seeding a corpus

To handle the `magic` function, Echidna needs some assistance. We will copy and modify the input to utilize appropriate parameters:

```
cp corpus-magic/coverage/2712688662897926208.txt corpus-magic/coverage/new.txt
```

Modify `new.txt` to call `magic(42,129,333,0)`. Now, re-run Echidna:

```
echidna magic.sol --config config.yaml
...
echidna_magic_values: failed!ðŸ’¥
  Call sequence:
    magic(42,129,333,0)

Unique instructions: 142
Unique codehashes: 1
Seed: -7293830866560616537

```

This time, the property fails immediately. We can verify that another `covered.*.txt` file is created, showing a different trace (labeled with `*`) that Echidna executed, which ended with a return at the end of the `magic` function.

```
  1 | *   | contract C {
  2 |     |     bool value_found = false;
  3 |     |
  4 | *   |     function magic(uint256 magic_1, uint256 magic_2, uint256 magic_3, uint256 magic_4) public {
  5 | *r  |         require(magic_1 == 42);
  6 | *r  |         require(magic_2 == 129);
  7 | *r  |         require(magic_3 == magic_4 + 333);
  8 | *   |         value_found = true;
  9 |     |         return;
 10 |     |     }
 11 |     |
 12 |     |     function echidna_magic_values() public returns (bool) {
 13 |     |         return !value_found;
 14 |     |     }
 15 |     | }
```

[File Ends] collecting-a-corpus.md

[File Begins] end-to-end-testing.md
# End-to-End Testing with Echidna (Part I)

When smart contracts require complex initialization and the time to do so is short, we want to avoid manually recreating a deployment for a fuzzing campaign with Echidna. That's why we have a new approach for testing using Echidna based on the deployments and execution of tests directly from Ganache.

## Requirements:

This approach needs a smart contract project with the following constraints:

- It should use Solidity; Vyper is not supported since Slither/Echidna is not very effective at running these (e.g. no AST is included).
- It should have tests or at least a complete deployment script.
- It should work with Slither. If it fails, [please report the issue](https://github.com/crytic/slither).

For this tutorial, [we used the Drizzle-box example](https://github.com/truffle-box/drizzle-box).

## Getting Started:

Before starting, make sure you have the latest releases from [Echidna](https://github.com/crytic/echidna/releases) and [Etheno](https://github.com/crytic/etheno/releases) installed.

Then, install the packages to compile the project:

```
git clone https://github.com/truffle-box/drizzle-box
cd drizzle-box
npm i truffle
```

If `ganache` is not installed, add it manually. In our example, we will run:

```
npm -g i ganache
```

Other projects using Yarn will require:

```
yarn global add ganache
```

Ensure that `$ ganache --version` outputs `ganache v7.3.2` or greater.

It is also important to select _one_ test script from the available tests. Ideally, this test will deploy all (or most) contracts, including mock/test ones. For this example, we are going to examine the `SimpleStorage` contract:

```solidity
contract SimpleStorage {
    event StorageSet(string _message);

    uint256 public storedData;

    function set(uint256 x) public {
        storedData = x;

        emit StorageSet("Data stored successfully!");
    }
}
```

This small contract allows the `storedData` state variable to be set. As expected, we have a unit test that deploys and tests this contract (`simplestorage.js`):

```js
const SimpleStorage = artifacts.require("SimpleStorage");

contract("SimpleStorage", (accounts) => {
    it("...should store the value 89.", async () => {
        const simpleStorageInstance = await SimpleStorage.deployed();

        // Set value of 89
        await simpleStorageInstance.set(89, { from: accounts[0] });

        // Get stored value
        const storedData = await simpleStorageInstance.storedData.call();

        assert.equal(storedData, 89, "The value 89 was not stored.");
    });
});
```

## Capturing Transactions

Before starting to write interesting properties, it is necessary to collect an Etheno trace to replay it inside Echidna:

First, start Etheno:

```bash
etheno --ganache --ganache-args="--miner.blockGasLimit 10000000" -x init.json
```

By default, the following Ganache arguments are set via Etheno:

- `-d`: Ganache will use a pre-defined, deterministic seed to create all accounts.
- `--chain.allowUnlimitedContractSize`: Allows unlimited contract sizes while debugging. This is set so that there is no size limitation on the contracts that are going to be deployed.
- `-p <port_num>`: The `port_num` will be set to (1) the value of `--ganache-port` or (2) Etheno will choose the smallest port number higher than the port number on which Ethenoâ€™s JSON RPC server is running.

**NOTE:** If you are using Docker to run Etheno, the commands should be:

```bash
docker run -it -p 8545:8545 -v ~/etheno:/home/etheno/ trailofbits/etheno
(you will now be working within the Docker instance)
etheno --ganache --ganache-args="--miner.blockGasLimit 10000000" -x init.json
```

- The `-p` in the _first command_ publishes (i.e., exposes) port 8545 from inside the Docker container out to port 8545 on the host.
- The `-v` in the _first command_ maps a directory from inside the Docker container to one outside the Docker container. After Etheno exits, the `init.json` file will now be in the `~/etheno` folder on the host.

Note that if the deployment fails to complete successfully due to a `ProviderError: exceeds block gas limit` exception, increasing the `--miner.blockGasLimit` value can help. This is especially helpful for large contract deployments. Learn more about the various Ganache command-line arguments that can be set by clicking [here](https://www.npmjs.com/package/ganache).

Additionally, if Etheno fails to produce any output, it may have failed to execute `ganache` under-the-hood. Check if `ganache` (with the associated command-line arguments) can be executed correctly from your terminal without the use of Etheno.

Meanwhile, in another terminal, run _one_ test or the deployment process. How to run it depends on how the project was developed. For instance, for Truffle, use:

```
truffle test test/test.js
```

For Buidler:

```
buidler test test/test.js --network localhost
```

In the Drizzle example, we will run:

```
truffle test test/simplestorage.js --network develop.
```

After Etheno finishes, gently kill it using Ctrl+C (or Command+C on Mac). It will save the `init.json` file. If your test fails for some reason, or you want to run a different one, restart Etheno and re-run the test.

## Writing and Running a Property

Once we have a JSON file with saved transactions, we can verify that the `SimpleStorage` contract is deployed at `0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c`. We can easily write a contract in `contracts/crytic/E2E.sol` with a simple property to test it:

```solidity
import "../SimpleStorage.sol";

contract E2E {
    SimpleStorage st = SimpleStorage(0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c);

    function crytic_const_storage() public returns (bool) {
        return st.storedData() == 89;
    }
}
```

For large, multi-contract deployments, using `console.log` to print out the deployed contract addresses can be valuable in quickly setting up the Echidna testing contract.

This simple property checks if the stored data remains constant. To run it, you will need the following Echidna config file (`echidna.yaml`):

```yaml
prefix: crytic_
initialize: init.json
allContracts: true
cryticArgs: ["--truffle-build-directory", "app/src/contracts/"] # needed by Drizzle
```

Then, running Echidna shows the results immediately:

```
echidna . --contract E2E --config echidna.yaml
...
crytic_const_storage: failed!ðŸ’¥
  Call sequence:
    (0x871dd7c2b4b25e1aa18728e9d5f2af4c4e431f5c).set(0) from: 0x0000000000000000000000000000000000010000
```

For this last step, make sure you are using `.` as a target for `echidna`. If you use the path to the `E2E.sol` file instead, Echidna will not be able to get information from all the deployed contracts to call the `set(uint256)` function, and the property will never fail.

## Key Considerations:

When using Etheno with Echidna, note that there are two edge cases that may cause unexpected behavior:

1. Function calls that use ether: The accounts created and used for testing in Ganache are not the same as the accounts used to send transactions in Echidna. Thus, the account balances of the Ganache accounts do not carry over to the accounts used by Echidna. If there is a function call logged by Etheno that requires the transfer of some ether from an account that exists in Ganache, this call will fail in Echidna.
2. Fuzz tests that rely on `block.timestamp`: The concept of time is different between Ganache and Echidna. Echidna always starts with a fixed timestamp, while Etheno will use Ganache's concept of time. This means that assertions or requirements in a fuzz test that rely on timestamp comparisons/evaluations may fail in Echidna.

In the next part of this tutorial, we will explore how to easily find where contracts are deployed with a specific tool based on Slither. This will be useful if the deployment process is complex, and we need to test a particular contract.

[File Ends] end-to-end-testing.md

[File Begins] finding-transactions-with-high-gas-consumption.md
# Identifying High Gas Consumption Transactions

**Table of contents:**

- [Identifying high gas consumption transactions](#identifying-high-gas-consumption-transactions)
  - [Introduction](#introduction)
  - [Measuring Gas Consumption](#measuring-gas-consumption)
- [Running Echidna](#running-echidna)
- [Excluding Gas-Reducing Calls](#excluding-gas-reducing-calls)
  - [Summary: Identifying high gas consumption transactions](#summary-identifying-high-gas-consumption-transactions)

## Introduction

This guide demonstrates how to identify transactions with high gas consumption using Echidna. The target is the following smart contract ([gas.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/gas.sol)):

```solidity
contract C {
    uint256 state;

    function expensive(uint8 times) internal {
        for (uint8 i = 0; i < times; i++) {
            state = state + i;
        }
    }

    function f(uint256 x, uint256 y, uint8 times) public {
        if (x == 42 && y == 123) {
            expensive(times);
        } else {
            state = 0;
        }
    }

    function echidna_test() public returns (bool) {
        return true;
    }
}
```

The `expensive` function can have significant gas consumption.

Currently, Echidna always requires a property to test - in this case, `echidna_test` always returns `true`.
We can run Echidna to verify this:

```
echidna gas.sol
...
echidna_test: passed! ðŸŽ‰

Seed: 2320549945714142710
```

## Measuring Gas Consumption

To enable Echidna's gas consumption feature, create a configuration file [gas.yaml](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/gas.yaml):

```yaml
estimateGas: true
```

In this example, we'll also reduce the size of the transaction sequence for easier interpretation:

```yaml
seqLen: 2
estimateGas: true
```

# Running Echidna

With the configuration file created, we can run Echidna as follows:

```
echidna gas.sol --config config.yaml
...
echidna_test: passed! ðŸŽ‰

f used a maximum of 1333608 gas
  Call sequence:
    f(42,123,249) Gas price: 0x10d5733f0a Time delay: 0x495e5 Block delay: 0x88b2

Unique instructions: 157
Unique codehashes: 1
Seed: -325611019680165325
```

- The displayed gas is an estimation provided by [HEVM](https://github.com/dapphub/dapptools/tree/master/src/hevm#hevm-).

# Excluding Gas-Reducing Calls

The tutorial on [filtering functions to call during a fuzzing campaign](../basic/filtering-functions.md) demonstrates how to remove certain functions during testing.
This can be crucial for obtaining accurate gas estimates.
Consider the following example ([example/pushpop.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/pushpop.sol)):

```solidity
contract C {
    address[] addrs;

    function push(address a) public {
        addrs.push(a);
    }

    function pop() public {
        addrs.pop();
    }

    function clear() public {
        addrs.length = 0;
    }

    function check() public {
        for (uint256 i = 0; i < addrs.length; i++)
            for (uint256 j = i + 1; j < addrs.length; j++) if (addrs[i] == addrs[j]) addrs[j] = address(0);
    }

    function echidna_test() public returns (bool) {
        return true;
    }
}
```

With this [`config.yaml`](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/pushpop.yaml), Echidna can call all functions but won't easily identify transactions with high gas consumption:

```
echidna pushpop.sol --config config.yaml
...
pop used a maximum of 10746 gas
...
check used a maximum of 23730 gas
...
clear used a maximum of 35916 gas
...
push used a maximum of 40839 gas
```

This occurs because the cost depends on the size of `addrs`, and random calls tend to leave the array almost empty.
By blacklisting `pop` and `clear`, we obtain better results ([blacklistpushpop.yaml](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/blacklistpushpop.yaml)):

```yaml
estimateGas: true
filterBlacklist: true
filterFunctions: ["C.pop()", "C.clear()"]
```

```
echidna pushpop.sol --config config.yaml
...
push used a maximum of 40839 gas
...
check used a maximum of 1484472 gas
```

## Summary: Identifying high gas consumption transactions

Echidna can identify transactions with high gas consumption using the `estimateGas` configuration option:

```yaml
estimateGas: true
```

```bash
echidna contract.sol --config config.yaml
...
```

After completing the fuzzing campaign, Echidna will report a sequence with the maximum gas consumption for each function.

[File Ends] finding-transactions-with-high-gas-consumption.md

[File Begins] hevm-cheats-to-test-permit.md
# Using HEVM Cheats To Test Permit

## Introduction

[EIP 2612](https://eips.ethereum.org/EIPS/eip-2612) introduces the function `permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)` to the ERC20 ABI. This function takes in signature parameters generated through ECDSA, combined with the [EIP 712](https://eips.ethereum.org/EIPS/eip-712) standard for typed data hashing, and recovers the author of the signature through `ecrecover()`. It then sets `allowances[owner][spender]` to `value`.

## Uses

This method presents a new way of allocating allowances, as signatures can be computed off-chain and passed to a contract. It allows a relayer to pay the entire gas fee of the permit transaction in exchange for a fee, enabling completely gasless transactions for a user. Furthermore, this removes the typical `approve() -> transferFrom()` pattern that forces users to send two transactions instead of just one through this new method.

Note that for the permit function to work, a valid signature is needed. This example will demonstrate how we can use [`hevm`'s `sign` cheatcode](https://github.com/dapphub/dapptools/blob/master/src/hevm/README.md#cheat-codes) to sign data with a private key. More generally, you can use this cheatcode to test anything that requires valid signatures.

## Example

We use Solmateâ€™s implementation of the ERC20 standard that includes the permit function. Observe that there are also values for the `PERMIT_TYPEHASH` and a `mapping(address -> uint256) public nonces`. The former is part of the EIP712 standard, and the latter is used to prevent signature replay attacks.

In our `TestDepositWithPermit` contract, we need to have the signature signed by an owner for validation. To accomplish this, we can use `hevm`â€™s `sign` cheatcode, which takes in a message and a private key and creates a valid signature. For this example, we use the private key `0x02`, and the following signed message representing the permit signature following the EIP 712:

```solidity
keccak256(
    abi.encodePacked(
        "\x19\x01",
        asset.DOMAIN_SEPARATOR(),
        keccak256(
            abi.encode(
                keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"),
                owner,
                spender,
                assetAmount,
                asset.nonces(owner),
                block.timestamp
            )
        )
    )
);
```

The helper function `getSignature(address owner, address spender, uint256 assetAmount)` returns a valid signature generated via the `sign` cheatcode. Note that the sign cheatcode exposes the private key, so it is best to use dummy keys when testing. Our keypair data was taken from [this site](https://privatekeys.pw/keys/ethereum/1). To test the signature, we will mint a random amount to the `OWNER` address, the address corresponding to the private key `0x02`, which was the signer of the permit signature. We then check whether we can use that signature to transfer the ownerâ€™s tokens to ourselves.

First, we call `permit()` on our Mock ERC20 token with the signature generated in `getSignature()`, and then call `transferFrom()`. If our permit request and transfer are successful, our balance of the mock ERC20 should increase by the amount permitted, and the `OWNER`'s balance should decrease as well. For simplicity, we'll transfer all the minted tokens so that the `OWNER`'s balance will be `0`, and our balance will be `amount`.

## Code

The complete example code can be found [here](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/TestDepositWithPermit.sol).

[File Ends] hevm-cheats-to-test-permit.md

[File Begins] interacting-with-offchain-data-via-ffi.md
# Interacting with off-chain data using the `ffi` cheatcode

## Introduction

It is possible for Echidna to interact with off-chain data by means of the `ffi` cheatcode. This function allows the caller to execute an arbitrary command on the system running Echidna and read its output, enabling the possibility of getting external data into a fuzzing campaign.

## A word of caution

In general, the usage of cheatcodes is not encouraged, since manipulating the EVM execution environment can lead to unpredictable results and false positives or negatives in fuzzing tests.

This piece of advice becomes more critical when using `ffi`. This cheatcode basically allows arbitrary code execution on the host system, so it's not just the EVM execution environment that can be manipulated. Running malicious or untrusted tests with `ffi` can have disastrous consequences.

The usage of this cheatcode should be extremely limited, well documented, and only reserved for cases where there is not a secure alternative.

## Pre-requisites

If reading the previous section didn't scare you enough and you still want to use `ffi`, you will need to explicitly tell Echidna to allow the cheatcode in the tests. This safety measure makes sure you don't accidentally execute `ffi` code.

To enable the cheatcode, set the `allowFFI` flag to `true` in your Echidna configuration file:

```yaml
allowFFI: true
```

## Uses

Some of the use cases for `ffi` are:

- Making prices or other information available on-chain during a fuzzing campaign. For example, you can use `ffi` to feed an oracle with "live" data.
- Get randomness in a test. As you know, there is no randomness source on-chain, so using this cheatcode you can get a random value from the device running the fuzz tests.
- Integrate with algorithms not ported to Solidity language, or perform comparisons between two implementations. Some examples for this item include signing and hashing, or custom calculations algorithms.

## Example: Call an off-chain program and read its output

This example will show how to create a simple call to an external executable, passing some values as parameters, and read its output. Keep in mind that the return values of the called program should be an abi-encoded data chunk that can be later decoded via `abi.decode()`. No newlines are allowed in the return values.

Before digging into the example, there's something else to keep in mind: When interacting with external processes, you will need to convert from Solidity data types to string, to pass values as arguments to the off-chain executable. You can use the [crytic/properties](https://github.com/crytic/properties) `toString` [helpers](https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol#L447) for converting.

For the example we will be creating a python example script that returns a random `uint256` value and a `bytes32` hash calculated from an integer input value. This doesn't represent a "useful" use case, but will be enough to show how the `ffi` cheatcode is used. Finally, we won't perform sanity checks for data types or values, we will just assume the input data will be correct.

This script was tested with Python 3.11, Web3 6.0.0 and eth-abi 4.0.0. Some functions had different names in prior versions of the libraries.

```python
import sys
import secrets
from web3 import Web3
from eth_abi import encode

# Usage: python3 script.py number
number = int(sys.argv[1])

# Generate a 10-byte random number
random = int(secrets.token_hex(10), 16)

# Generate the keccak hash of the input value
hashed = Web3.solidity_keccak(['uint256'], [number])

# ABI-encode the output
abi_encoded = encode(['uint256', 'bytes32'], [random, hashed]).hex()

# Make sure that it doesn't print a newline character
print("0x" + abi_encoded, end="")
```

You can test this program with various inputs and see what the output is. If it works correctly, the program should output a 512-bit hex string that is the ABI-encoded representation of a 256-bit integer followed by a bytes32.

Now let's create the Solidity contract that will be run by Echidna to interact with the previous script.

```solidity
pragma solidity ^0.8.0;

// HEVM helper
import "@crytic/properties/contracts/util/Hevm.sol";

// Helpers to convert uint256 to string
import "@crytic/properties/contracts/util/PropertiesHelper.sol";

contract TestFFI {
    function test_ffi(uint256 number) public {
        // Prepare the array of executable and parameters
        string[] memory inp = new string[](3);
        inp[0] = "python3";
        inp[1] = "script.py";
        inp[2] = PropertiesLibString.toString(number);

        // Call the program outside the EVM environment
        bytes memory res = hevm.ffi(inp);

        // Decode the return values
        (uint256 random, bytes32 hashed) = abi.decode(res, (uint256, bytes32));

        // Make sure the return value is the expected
        bytes32 hashed_solidity = keccak256(abi.encodePacked(number));
        assert(hashed_solidity == hashed);
    }
}
```

The minimal configuration file for this test is the following:

```yaml
testMode: "assertion"
allowFFI: true
```

[File Ends] interacting-with-offchain-data-via-ffi.md

[File Begins] on-using-cheat-codes.md
# How and when to use cheat codes

**Table of contents:**

- [How and when to use cheat codes](#how-and-when-to-use-cheat-codes)
  - [Introduction](#introduction)
  - [Cheat codes available in Echidna](#cheat-codes-available-in-echidna)
  - [Advice on the use of cheat codes](#advice-on-the-use-of-cheat-codes)

## Introduction

When testing smart contracts in Solidity itself, it can be helpful to use cheat codes in order to overcome some of the limitations of the EVM/Solidity.
Cheat codes are special functions that allow to change the state of the EVM in ways that are not posible in production. These were introduced by Dapptools in hevm and adopted (and expanded) in other projects such as Foundry.

## Cheat codes available in Echidna

Echidna supports all cheat codes that are available in [hevm](https://github.com/ethereum/hevm). These are documented here: https://hevm.dev/controlling-the-unit-testing-environment.html#cheat-codes.
If a new cheat code is added in the future, Echidna only needs to update the hevm version and everything should work out of the box.

As an example, the `prank` cheat code is able to set the `msg.sender` address in the context of the next external call:

```solidity
interface IHevm {
    function prank(address) external;
}

contract TestPrank {
  address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
  IHevm hevm = IHevm(HEVM_ADDRESS);
  Contract c = ...

  function prankContract() public payable {
    hevm.prank(address(0x42424242);
    c.f(); // `c` will be called with `msg.sender = 0x42424242`
  }
}
```

A specific example on the use of `sign` cheat code is available [here in our documentation](hevm-cheats-to-test-permit.md).

## Risks of cheat codes

While we provide support for the use of cheat codes, these should be used responsibly. Consider that:

- Cheat codes can break certain assumptions in Solidity. For example, the compiler assumes that `block.number` is constant during a transaction. There are [reports of the optimizer interfering with (re)computation of the `block.number` or `block.timestamp`](https://github.com/ethereum/solidity/issues/12963#issuecomment-1110162425), which can generate incorrect tests when using cheat codes.

- Cheat codes can introduce false positives on the testing. For instance, using `prank` to simulate calls from a contract can allow transactions that are not possible in the blockchain.

- Using too many cheat codes:
  - can be confusing or error-prone. Certain cheat code like `prank` allow to change caller in the next external call: It can be difficult to follow, in particular if it is used in internal functions or modifiers.
  - will create a dependency of your code with the particular tool or cheat code implementation: It can cause produce migrations to other tools or reusing the test code to be more difficult than expected.

[File Ends] on-using-cheat-codes.md

[File Begins] optimization_mode.md
# Finding Local Maximums Using Optimization Mode

**Table of Contents:**

- [Finding Local Maximums Using Optimization Mode](#finding-local-maximums-using-optimization-mode)
  - [Introduction](#introduction)
  - [Optimizing with Echidna](#optimizing-with-echidna)

## Introduction

In this tutorial, we will explore how to perform function optimization using Echidna. Please ensure you have updated Echidna to version 2.0.5 or greater before proceeding.

Optimization mode is an experimental feature that enables the definition of a special function, taking no arguments and returning an `int256`. Echidna will attempt to find a sequence of transactions to maximize the value returned:

```solidity
function echidna_opt_function() public view returns (int256) {
    // If it reverts, Echidna will assume it returned type(int256).min
    return value;
}
```

## Optimizing with Echidna

In this example, the target is the following smart contract ([opt.sol](https://github.com/crytic/building-secure-contracts/blob/master/program-analysis/echidna/example/opt.sol)):

```solidity
contract TestDutchAuctionOptimization {
    int256 maxPriceDifference;

    function setMaxPriceDifference(uint256 startPrice, uint256 endPrice, uint256 startTime, uint256 endTime) public {
        if (endTime < (startTime + 900)) revert();
        if (startPrice <= endPrice) revert();

        uint256 numerator = (startPrice - endPrice) * (block.timestamp - startTime);
        uint256 denominator = endTime - startTime;
        uint256 stepDecrease = numerator / denominator;
        uint256 currentAuctionPrice = startPrice - stepDecrease;

        if (currentAuctionPrice < endPrice) {
            maxPriceDifference = int256(endPrice - currentAuctionPrice);
        }
        if (currentAuctionPrice > startPrice) {
            maxPriceDifference = int256(currentAuctionPrice - startPrice);
        }
    }

    function echidna_opt_price_difference() public view returns (int256) {
        return maxPriceDifference;
    }
}
```

This small example directs Echidna to maximize a specific price difference given certain preconditions. If the preconditions are not met, the function will revert without changing the actual value.

To run this example:

```
echidna opt.sol --test-mode optimization --test-limit 100000 --seq-len 1 --corpus-dir corpus --shrink-limit 50000
...
echidna_opt_price_difference: max value: 1076841

  Call sequence, shrinking (42912/50000):
    setMaxPriceDifference(1349752405,1155321,609,1524172858) Time delay: 603902 seconds Block delay: 21

```

The resulting max value is not unique; running a longer campaign will likely yield a larger value.

Regarding the command line, optimization mode is enabled using `--test-mode optimization`. Additionally, we included the following tweaks:

1. Use only one transaction (as we know the function is stateless).
2. Use a large shrink limit to obtain a better value during input complexity minimization.

Each time Echidna is executed using the corpus directory, the last input producing the maximum value should be reused from the `reproducers` directory:

```
echidna opt.sol --test-mode optimization --test-limit 100000 --seq-len 1 --corpus-dir corpus --shrink-limit 50000
Loaded total of 1 transactions from corpus/reproducers/
Loaded total of 9 transactions from corpus/coverage/
Analyzing contract: /home/g/Code/echidna/opt.sol:TestDutchAuctionOptimization
echidna_opt_price_difference: max value: 1146878

  Call sequence:
    setMaxPriceDifference(1538793592,1155321,609,1524172858) Time delay: 523701 seconds Block delay: 49387
```

[File Ends] optimization_mode.md

[File Begins] smart-contract-fuzzing-at-scale.md
# Fuzzing Smart Contracts at Scale with Echidna

In this tutorial, we will review how to create a dedicated server for fuzzing smart contracts using Echidna.

### Workflow:

1. Install and set up a dedicated server
2. Begin a short fuzzing campaign
3. Initiate a continuous fuzzing campaign
4. Add properties, check coverage, and modify the code if necessary
5. Conclude the campaign

## 1. Install and set up a dedicated server

First, obtain a dedicated server with at least 32 GB of RAM and as many cores as possible. Start by creating a user for the fuzzing campaign.
**Only use the root account to create an unprivileged user**:

```
# adduser echidna
# usermod -aG sudo echidna
```

Then, using the `echidna` user, install some basic dependencies:

```
sudo apt install unzip python3-pip
```

Next, install everything necessary to build your smart contract(s) as well as `slither` and `echidna-parade`. For example:

```
pip3 install solc-select
solc-select install all
pip3 install slither_analyzer
pip3 install echidna_parade
```

Add `$PATH=$PATH:/home/echidna/.local/bin` at the end of `/home/echidna/.bashrc`.

Afterward, install Echidna. The easiest way is to download the latest precompiled Echidna release, uncompress it, and move it to `/home/echidna/.local/bin`:

```
wget "https://github.com/crytic/echidna/releases/download/v2.0.0/echidna-test-2.0.0-Ubuntu-18.04.tar.gz"
tar -xf echidna-test-2.0.0-Ubuntu-18.04.tar.gz
mv echidna-test /home/echidna/.local/bin
```

## 2. Begin a short fuzzing campaign

Select a contract to test and provide initialization if needed. It does not have to be perfect; begin with some basic items and iterate over the results.
Before starting this campaign, modify your Echidna config to define a corpus directory to use. For instance:

```
corpusDir: "corpus-exploration"
```

This directory will be automatically created, but since we are starting a new campaign, **please remove the corpus directory if it was created by a previous Echidna campaign**.
If you don't have any properties to test, you can use:

```
testMode: exploration
```

to allow Echidna to run without any properties.

We will start a brief Echidna run (5 minutes) to check that everything looks fine. To do that, use the following config:

```
testLimit: 100000000000
timeout: 300 # 5 minutes
```

Once it runs, check the coverage file located in `corpus-exploration/covered.*.txt`. If the initialization is incorrect, **clear the `corpus-exploration` directory** and restart the campaign.

## 3. Initiate a continuous fuzzing campaign

When satisfied with the first iteration of the initialization, we can start a "continuous campaign" for exploration and testing using [echidna-parade](https://github.com/agroce/echidna-parade). Before starting, double-check your config file. For instance, if you added properties, do not forget to remove `benchmarkMode`.

`echidna-parade` is a tool used to launch multiple Echidna instances simultaneously while keeping track of each corpus. Each instance will be configured to run for a specific duration, with different parameters, to maximize the chance of reaching new code.

We will demonstrate this with an example, where:

- the initial corpus is empty
- the base config file is `exploration.yaml`
- the initial instance will run for 3600 seconds (1 hour)
- each "generation" will run for 1800 seconds (30 minutes)
- the campaign will run in continuous mode (if the timeout is -1, it means run indefinitely)
- there will be 8 Echidna instances per generation. Adjust this according to the number of available cores, but avoid using all of your cores if you do not want to overload your server
- the target contract is named `C`
- the file containing the contract is `test.sol`

Finally, we will log the stdout and stderr in `parade.log` and `parade.err` and fork the process to let it run indefinitely.

```
echidna-parade test.sol --config exploration.yaml --initial_time 3600 --gen_time 1800 --timeout -1 --ncores 8 --contract C > parade.log 2> parade.err &
```

**After running this command, exit the shell to avoid accidentally killing it if your connection fails.**

## 4. Add more properties, check coverage, and modify the code if necessary

In this step, we can add more properties while Echidna explores the contracts. Keep in mind that you should avoid changing the contracts' ABI
(otherwise, the quality of the corpus will degrade).

Additionally, we can tweak the code to improve coverage, but before starting, we need to know how to monitor our fuzzing campaign. We can use this command:

```
watch "grep 'COLLECTING NEW COVERAGE' parade.log | tail -n 30"
```

When new coverage is found, you will see something like this:

```
COLLECTING NEW COVERAGE: parade.181140/gen.30.10/corpus/coverage/-3538310549422809236.txt
COLLECTING NEW COVERAGE: parade.181140/gen.35.9/corpus/coverage/5960152130200926175.txt
COLLECTING NEW COVERAGE: parade.181140/gen.35.10/corpus/coverage/3416698846701985227.txt
COLLECTING NEW COVERAGE: parade.181140/gen.36.6/corpus/coverage/-3997334938716772896.txt
COLLECTING NEW COVERAGE: parade.181140/gen.37.7/corpus/coverage/323061126212903141.txt
COLLECTING NEW COVERAGE: parade.181140/gen.37.6/corpus/coverage/6733481703877290093.txt
```

You can verify the corresponding covered file, such as `parade.181140/gen.37.6/corpus/covered.1615497368.txt`.

For examples on how to help Echidna improve its coverage, please review the [improving coverage tutorial](./collecting-a-corpus.md).

To monitor failed properties, use this command:

```
watch "grep 'FAIL' parade.log | tail -n 30"
```

When failed properties are found, you will see something like this:

```
NEW FAILURE: assertion in f: failed!ðŸ’¥
parade.181140/gen.179.0 FAILED
parade.181140/gen.179.3 FAILED
parade.181140/gen.180.2 FAILED
parade.181140/gen.180.4 FAILED
parade.181140/gen.180.3 FAILED
...
```

## 5. Conclude the campaign

When satisfied with the coverage results, you can terminate the continuous campaign using:

```
killall echidna-parade echidna
```

[File Ends] smart-contract-fuzzing-at-scale.md

[File Begins] state-network-forking.md
# On-chain fuzzing with state forking

**Table of contents:**

- [On-chain fuzzing with state forking](#on-chain-fuzzing-with-state-forking)
  - [Introduction](#introduction)
  - [Example](#example)
  - [Corpus and RPC cache](#corpus-and-rpc-cache)
  - [Coverage and Etherscan integration](#coverage-and-etherscan-integration)

## Introduction

Echidna recently added support for state network forking, starting from the 2.1.0 release. In a few words, our fuzzer can run a campaign starting with an existing blockchain state provided by an external RPC service (Infura, Alchemy, local node, etc). This enables users to speed up the fuzzing setup when using already deployed contracts.

## Example

In the following contract, an assertion will fail if the call to [Compound ETH](https://etherscan.io/token/0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) `mint` function succeeds and the balance of the contract increases.

```solidity
interface IHevm {
    function warp(uint256 newTimestamp) external;

    function roll(uint256 newNumber) external;
}

interface Compound {
    function mint() external payable;

    function balanceOf(address) external view returns (uint256);
}

contract TestCompoundEthMint {
    address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;
    IHevm hevm = IHevm(HEVM_ADDRESS);
    Compound comp = Compound(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5);

    constructor() {
        hevm.roll(16771449); // sets the correct block number
        hevm.warp(1678131671); // sets the expected timestamp for the block number
    }

    function assertNoBalance() public payable {
        require(comp.balanceOf(address(this)) == 0);
        comp.mint{ value: msg.value }();
        assert(comp.balanceOf(address(this)) == 0);
    }
}
```

In order to use this feature, the user needs to specify the RPC endpoint for Echidna to use before running the fuzzing campaign. This requires using the `ECHIDNA_RPC_URL` and `ECHIDNA_RPC_BLOCK` environment variables:

```
$ ECHIDNA_RPC_URL=http://.. ECHIDNA_RPC_BLOCK=16771449 echidna compound.sol --test-mode assertion --contract TestCompoundEthMint
...
assertNoBalance(): failed!ðŸ’¥
  Call sequence, shrinking (885/5000):
    assertNoBalance() Value: 0xd0411a5
```

Echidna will query contract code or storage slots as needed from the provided RPC node. You can press the key `f` key to see which contracts/slots are fetched.

Please note that only the state specified in the `ECHIDNA_RPC_BLOCK` will be fetched. If Echidna increases the block number, it is all just simulated locally but its state is still loaded from the initially set RPC block.

## Corpus and RPC cache

If a corpus directory is used (e.g. `--corpus-dir corpus`), Echidna will save the fetched information inside the `cache` directory.
This will speed up subsequent runs, since the data does not need to be fetched from the RPC. It is recommended to use this feature, in particular if the testing is performed as part of the CI tests.

```
$ ls corpus/cache/
block_16771449_fetch_cache_contracts.json  block_16771449_fetch_cache_slots.json
```

## Coverage and Etherscan integration

When the fuzzing campaign is over, if the source code mapping of any executed on-chain contract is available on Etherscan, it will be fetched automatically for the coverage report. Optionally, an Etherscan key can be provided using the `ETHERSCAN_API_KEY` environment variable.

```
Fetching Solidity source for contract at address 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5... Retrying (5 left). Error: Max rate limit reached, please use API Key for higher rate limit
Retrying (4 left). Error: Max rate limit reached, please use API Key for higher rate limit
Retrying (3 left). Error: Max rate limit reached, please use API Key for higher rate limit
Success!
Fetching Solidity source map for contract at address 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5... Error!
```

While the source code for the [cETH contract is available](https://etherscan.io/address/0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5#code), their source maps are NOT.
In order to generate the coverage report for a fetched contract, **both** source code and source mapping should be available. In that case, there will be a new directory inside the corpus directory to show coverage for each contract that was fetched. In any case, the coverage report will be always available for the user-provided contracts, such as this one:

```
20 |     |
21 | *r  |   function assertNoBalance() public payable {
22 | *r  |     require(comp.balanceOf(address(this)) == 0);
23 | *r  |     comp.mint{value: msg.value}();
24 | *r  |     assert(comp.balanceOf(address(this)) == 0);
25 |     |   }
```

[File Ends] state-network-forking.md

[File Begins] testing-bytecode.md
# How to Test Bytecode-Only Contracts

**Table of contents:**

- [How to Test Bytecode-Only Contracts](#how-to-test-bytecode-only-contracts)
  - [Introduction](#introduction)
  - [Proxy Pattern](#proxy-pattern)
  - [Running Echidna](#running-echidna)
    - [Target Source Code](#target-source-code)
  - [Differential Fuzzing](#differential-fuzzing)
  - [Generic Proxy Code](#generic-proxy-code)
  - [Summary: Testing Contracts Without Source Code](#summary-testing-contracts-without-source-code)

## Introduction

In this tutorial, you'll learn how to fuzz a contract without any provided source code. The technique can also be used to perform differential fuzzing (i.e., compare multiple implementations) between a Solidity contract and a Vyper contract.

Consider the following bytecode:

```
608060405234801561001057600080fd5b506103e86000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506103e86001819055506101fa8061006e6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806318160ddd1461004657806370a0823114610064578063a9059cbb146100bc575b600080fd5b61004e61010a565b6040518082815260200191505060405180910390f35b6100a66004803603602081101561007a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610110565b6040518082815260200191505060405180910390f35b610108600480360360408110156100d257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610128565b005b60015481565b60006020528060005260406000206000915090505481565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550505056fe
```

For which we only know the ABI:

```solidity
interface Target {
    function totalSupply() external returns (uint256);

    function balanceOf(address) external returns (uint256);

    function transfer(address, uint256) external;
}
```

We want to test if it is possible to have more tokens than the total supply.

## Proxy Pattern

Since we don't have the source code, we can't directly add the property to the contract. Instead, we'll use a proxy contract:

```solidity
interface Target {
    function totalSupply() external returns (uint256);

    function balanceOf(address) external returns (uint256);

    function transfer(address, uint256) external;
}

contract TestBytecodeOnly {
    Target target;

    constructor() {
        address targetAddress;
        // init bytecode
        bytes
            memory targetCreationBytecode = hex"608060405234801561001057600080fd5b506103e86000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506103e86001819055506101fa8061006e6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806318160ddd1461004657806370a0823114610064578063a9059cbb146100bc575b600080fd5b61004e61010a565b6040518082815260200191505060405180910390f35b6100a66004803603602081101561007a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610110565b6040518082815260200191505060405180910390f35b610108600480360360408110156100d257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610128565b005b60015481565b60006020528060005260406000206000915090505481565b806000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550806000808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540192505081905550505056fe";

        uint256 size = targetCreationBytecode.length;

        assembly {
            targetAddress := create(0, add(targetCreationBytecode, 0x20), size) // Skip the 32 bytes encoded length.
        }

        target = Target(targetAddress);
    }

    function transfer(address to, uint256 amount) public {
        target.transfer(to, amount);
    }

    function echidna_test_balance() public returns (bool) {
        return target.balanceOf(address(this)) <= target.totalSupply();
    }
}
```

The proxy:

- Deploys the bytecode in its constructor
- Has one function that calls the target's `transfer` function
- Has one Echidna property `target.balanceOf(address(this)) <= target.totalSupply()`

## Running Echidna

```bash
echidna bytecode_only.sol --contract TestBytecodeOnly
echidna_test_balance: failed!ðŸ’¥
  Call sequence:
    transfer(0x0,1002)
```

Here, Echidna found that by calling `transfer(0, 1002)` anyone can mint tokens.

### Target Source Code

The actual source code of the target is:

```solidity
contract C {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    constructor() public {
        balanceOf[msg.sender] = 1000;
        totalSupply = 1000;
    }

    function transfer(address to, uint256 amount) public {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
    }
}
```

Echidna correctly found the bug: lack of overflow checks in `transfer`.

## Differential Fuzzing

Consider the following Vyper and Solidity contracts:

```vyper
@view
@external
def my_func(a: uint256, b: uint256, c: uint256) -> uint256:
    return a * b / c
```

```solidity
contract SolidityVersion {
    function my_func(uint256 a, uint256 b, uint256 c) public view {
        return (a * b) / c;
    }
}
```

We can test that they always return the same values using the proxy pattern:

```solidity
interface Target {
    function my_func(uint256, uint256, uint256) external returns (uint256);
}

contract SolidityVersion {
    Target target;

    constructor() public {
        address targetAddress;

        // vyper bytecode
        bytes
            memory targetCreationBytecode = hex"61007756341561000a57600080fd5b60043610156100185761006d565b600035601c52630ff198a3600051141561006c57600435602435808202821582848304141761004657600080fd5b80905090509050604435808061005b57600080fd5b82049050905060005260206000f350005b5b60006000fd5b61000461007703610004600039610004610077036000f3";

        uint256 size = targetCreationBytecode.length;

        assembly {
            targetAddress := create(0, add(targetCreationBytecode, 0x20), size) // Skip the 32 bytes encoded length.
        }
        target = Target(targetAddress);
    }

    function test(uint256 a, uint256 b, uint256 c) public returns (bool) {
        assert(my_func(a, b, c) == target.my_func(a, b, c));
    }

    function my_func(uint256 a, uint256 b, uint256 c) internal view returns (uint256) {
        return (a * b) / c;
    }
}
```

Here we run Echidna with the [assertion mode](../basic/assertion-checking.md):

```
echidna  vyper.sol --config config.yaml --contract SolidityVersion --test-mode assertion
assertion in test: passed! ðŸŽ‰
```

## Generic Proxy Code

Adapt the following code to your needs:

```solidity
interface Target {
    // public/external functions
}

contract TestBytecodeOnly {
    Target target;

    constructor() public {
        address targetAddress;
        // init bytecode
        bytes memory targetCreationBytecode = hex"";

        uint256 size = targetCreationBytecode.length;

        assembly {
            targetAddress := create(0, add(targetCreationBytecode, 0x20), size) // Skip the 32 bytes encoded length.
        }
        target = Target(targetAddress);
    }

    // Add helper functions to call the target's functions from the proxy

    function echidna_test() public returns (bool) {
        // The property to test
    }
}
```

## Summary: Testing Contracts Without Source Code

Echidna can fuzz contracts without source code using a proxy contract. This technique can also be used to compare implementations written in Solidity and Vyper.

[File Ends] testing-bytecode.md

[File Begins] using-all-contracts.md
# Understanding and using `allContracts` in Echidna

**Table of contents:**

- [Understanding and using `allContracts` in Echidna](#understanding-and-using-allContracts-in-echidna)
  - [Introduction](#introduction)
  - [What is `allContracts` testing?](#what-is-allContracts-testing)
  - [When and how to use `allContracts`](#when-and-how-to-use-allContracts)
  - [Run Echidna](#run-echidna)
    - [Example run with `allContracts` set to `false`](#example-run-with-allContracts-set-to-false)
    - [Example run with `allContracts` set to `true`](#example-run-with-allContracts-set-to-true)
  - [Use cases and conclusions](#use-cases-and-conclusions)

## Introduction

This tutorial is written as a hands-on guide to using `allContracts` testing in Echidna. You will learn what `allContracts` testing is, how to use it in your tests, and what to expect from its usage.

> This feature used to be called `multi-abi` but it was later renamed to `allContracts` in Echidna 2.1.0. As expected, this version or later is required for this tutorial.

## What is `allContracts` testing?

It is a testing mode that allows Echidna to call functions from any contract not directly under test. The ABI for the contract must be known, and it must have been deployed by the contract under test.

## When and how to use `allContracts`

By default, Echidna calls functions from the contract to be analyzed, sending the transactions randomly from addresses `0x10000`, `0x20000` and `0x30000`.

In some systems, the user has to interact with other contracts prior to calling a function on the fuzzed contract. A common example is when you want to provide liquidity to a DeFi protocol, you will first need to approve the protocol for spending your tokens. This transaction has to be initiated from your account before actually interacting with the protocol contract.

A fuzzing campaign meant to test this example protocol contract won't be able to modify users allowances, therefore most of the interactions with the protocol won't be tested correctly.

This is where `allContracts` testing is useful: It allows Echidna to call functions from other contracts (not just from the contract under test), sending the transactions from the same accounts that will interact with the target contract.

## Run Echidna

We will use a simple example to show how `allContracts` works. We will be using two contracts, `Flag` and `EchidnaTest`, both available in [allContracts.sol](../example/allContracts.sol).

The `Flag` contract contains a boolean flag that is only set if `flip()` is called, and a getter function that returns the value of the flag. For now, ignore `test_fail()`, we will talk about this function later.

```solidity
contract Flag {
    bool flag = false;

    function flip() public {
        flag = !flag;
    }

    function get() public returns (bool) {
        return flag;
    }

    function test_fail() public {
        assert(false);
    }
}
```

The test harness will instantiate a new `Flag`, and the invariant under test will be that `f.get()` (that is, the boolean value of the flag) is always false.

```solidity
contract EchidnaTest {
    Flag f;

    constructor() {
        f = new Flag();
    }

    function test_flag_is_false() public {
        assert(f.get() == false);
    }
}
```

In a non `allContracts` fuzzing campaign, Echidna is not able to break the invariant, because it only interacts with `EchidnaTest` functions. However, if we use the following configuration file, enabling `allContracts` testing, the invariant is broken. You can access [allContracts.yaml here](../example/allContracts.yaml).

```yaml
testMode: assertion
testLimit: 50000
allContracts: true
```

To run the Echidna tests, run `echidna allContracts.sol --contract EchidnaTest --config allContracts.yaml` from the `example` directory. Alternatively, you can specify `--all-contracts` in the command line instead of using a configuration file.

### Example run with `allContracts` set to `false`

```
echidna allContracts.sol --contract EchidnaTest --config allContracts.yaml
Analyzing contract: building-secure-contracts/program-analysis/echidna/example/allContracts.sol:EchidnaTest
test_flag_is_false():  passed! ðŸŽ‰
AssertionFailed(..):  passed! ðŸŽ‰

Unique instructions: 282
Unique codehashes: 2
Corpus size: 2
Seed: -8252538430849362039
```

### Example run with `allContracts` set to `true`

```
echidna allContracts.sol --contract EchidnaTest --config allContracts.yaml
Analyzing contract: building-secure-contracts/program-analysis/echidna/example/allContracts.sol:EchidnaTest
test_flag_is_false(): failed!ðŸ’¥
  Call sequence:
    flip()
    flip()
    flip()
    test_flag_is_false()

Event sequence: Panic(1)
AssertionFailed(..):  passed! ðŸŽ‰

Unique instructions: 368
Unique codehashes: 2
Corpus size: 6
Seed: -6168343983565830424
```

## Use cases and conclusions

Testing with `allContracts` is a useful tool for complex systems that require the user to interact with more than one contract, as we mentioned earlier. Another use case is for deployed contracts that require interactions to be initiated by specific addresses: for those, specifying the `sender` configuration setting allows to send the transactions from the correct account.

A side-effect of using `allContracts` is that the search space grows with the number of functions that can be called. This, combined with high values of sequence lengths, can make the fuzzing test not so thorough, because the dimension of the search space is simply too big to reasonably explore. Finally, adding more functions as fuzzing candidates makes the campaigns to take up more execution time.

A final remark is that `allContracts` testing in assertion mode ignores all assert failures from the contracts not under test. This is shown in `Flag.test_fail()` function: even though it explicitly asserts false, the Echidna test ignores it.

[File Ends] using-all-contracts.md

[File Begins] working-with-libraries.md
# Working with external libraries

**Table of contents:**

- [Introduction](#introduction)
- [Example code](#example-code)
- [Deploying libraries](#deploying-libraries)
- [Linking libraries](#linking-libraries)
- [Summary](#summary)

## Introduction

Solidity support two types of libraries ([see the documentation](https://docs.soliditylang.org/en/v0.8.19/contracts.html#libraries)):

- If all the functions are internal, the library is compiled into bytecode and added into the contracts that use it.
- If there are some external functions, the library should be deployed into some address. Finally, the bytecode calling the library should be linked.

The following is only needed if your codebase uses libraries that need to be linked.

## Example code

For this tutorial, we will use [the metacoin example](https://github.com/truffle-box/metacoin-box). Let's start compiling it:

```
$ git clone https://github.com/truffle-box/metacoin-box
$ cd metacoin-box
$ npm i
```

## Deploying libraries

Libraries are contracts that need to be deployed first. Fortunately, Echidna allows us to do that easily, using the `deployContracts` option. In the metacoin example, we can use:

```yaml
deployContracts: [["0x1f", "ConvertLib"]]
```

The address where the library should be deployed is arbitrary, but it should be the same as the one in the used during the linking process.

## Linking libraries

Before a contract can use a deployed library, its bytecode requires to be linked (e.g set the address that points to the deployed library contract). Normally, a compilation framework (e.g. truffle) will take care of this. However, in our case, we will use `crytic-compile`, since it is easier to handle all cases from different frameworks just adding one new argument to pass to `crytic-compile` from Echidna:

```yaml
cryticArgs: ["--compile-libraries=(ConvertLib,0x1f)"]
```

Going back to the example, if we have both config options in a single config file (`echidna.yaml`), we can run the metacoin contract
in `exploration` mode:

```
$ echidna . --test-mode exploration --corpus-dir corpus --contract MetaCoin --config echidna.yaml
```

We can use the coverage report to verify that function using the library (`getBalanceInEth`) is not reverting:

```
 28 | *   |     function getBalanceInEth(address addr) public view returns(uint){
 29 | *   |             return ConvertLib.convert(getBalance(addr),2);
 30 |     |     }
```

## Summary

Working with libraries in Echidna is supported. It involves to deploy the library to a particular address using `deployContracts` and then asking `crytic-compile` to link the bytecode with the same address using `--compile-libraries` command line.

[File Ends] working-with-libraries.md


<-- File Content Ends

